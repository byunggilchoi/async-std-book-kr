<!DOCTYPE HTML>
<html lang="kr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Handling Disconnection - Async programming in Rust with async-std - kr</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../overview/async-std.html"><strong aria-hidden="true">1.1.</strong> Welcome to async-std!</a></li><li class="chapter-item expanded "><a href="../overview/std-and-library-futures.html"><strong aria-hidden="true">1.2.</strong> std::future and futures-rs</a></li><li class="chapter-item expanded "><a href="../overview/stability-guarantees.html"><strong aria-hidden="true">1.3.</strong> Stability guarantees</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts.html"><strong aria-hidden="true">2.</strong> Async concepts using async-std</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/futures.html"><strong aria-hidden="true">2.1.</strong> Futures</a></li><li class="chapter-item expanded "><a href="../concepts/tasks.html"><strong aria-hidden="true">2.2.</strong> Tasks</a></li><li class="chapter-item expanded "><a href="../concepts/async-read-write.html"><strong aria-hidden="true">2.3.</strong> Async read/write</a></li><li class="chapter-item expanded "><a href="../concepts/streams.html"><strong aria-hidden="true">2.4.</strong> Streams and Channels</a></li></ol></li><li class="chapter-item expanded "><a href="../tutorial/index.html"><strong aria-hidden="true">3.</strong> Tutorial: Implementing a chat</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorial/specification.html"><strong aria-hidden="true">3.1.</strong> Specification and Getting started</a></li><li class="chapter-item expanded "><a href="../tutorial/accept_loop.html"><strong aria-hidden="true">3.2.</strong> Writing an Accept Loop</a></li><li class="chapter-item expanded "><a href="../tutorial/receiving_messages.html"><strong aria-hidden="true">3.3.</strong> Receiving Messages</a></li><li class="chapter-item expanded "><a href="../tutorial/sending_messages.html"><strong aria-hidden="true">3.4.</strong> Sending Messages</a></li><li class="chapter-item expanded "><a href="../tutorial/connecting_readers_and_writers.html"><strong aria-hidden="true">3.5.</strong> Connecting Readers and Writers</a></li><li class="chapter-item expanded "><a href="../tutorial/all_together.html"><strong aria-hidden="true">3.6.</strong> All Together</a></li><li class="chapter-item expanded "><a href="../tutorial/clean_shutdown.html"><strong aria-hidden="true">3.7.</strong> Clean Shutdown</a></li><li class="chapter-item expanded "><a href="../tutorial/handling_disconnection.html" class="active"><strong aria-hidden="true">3.8.</strong> Handling Disconnection</a></li><li class="chapter-item expanded "><a href="../tutorial/implementing_a_client.html"><strong aria-hidden="true">3.9.</strong> Implementing a Client</a></li></ol></li><li class="chapter-item expanded "><a href="../patterns.html"><strong aria-hidden="true">4.</strong> Async Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/small-patterns.html"><strong aria-hidden="true">4.1.</strong> TODO: Collected Small Patterns</a></li><li class="chapter-item expanded "><a href="../patterns/accept-loop.html"><strong aria-hidden="true">4.2.</strong> Production-Ready Accept Loop</a></li></ol></li><li class="chapter-item expanded "><a href="../security/index.html"><strong aria-hidden="true">5.</strong> Security practices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../security/policy.html"><strong aria-hidden="true">5.1.</strong> Security Disclosures and Policy</a></li></ol></li><li class="chapter-item expanded "><a href="../glossary.html"><strong aria-hidden="true">6.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Async programming in Rust with async-std - kr</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#handling-disconnections" id="handling-disconnections">Handling Disconnections</a></h2>
<p>Currently, we only ever <em>add</em> new peers to the map.
This is clearly wrong: if a peer closes connection to the chat, we should not try to send any more messages to it.</p>
<p>One subtlety with handling disconnection is that we can detect it either in the reader's task, or in the writer's task.
The most obvious solution here is to just remove the peer from the <code>peers</code> map in both cases, but this would be wrong.
If <em>both</em> read and write fail, we'll remove the peer twice, but it can be the case that the peer reconnected between the two failures!
To fix this, we will only remove the peer when the write side finishes.
If the read side finishes we will notify the write side that it should stop as well.
That is, we need to add an ability to signal shutdown for the writer task.</p>
<p>One way to approach this is a <code>shutdown: Receiver&lt;()&gt;</code> channel.
There's a more minimal solution however, which makes clever use of RAII.
Closing a channel is a synchronization event, so we don't need to send a shutdown message, we can just drop the sender.
This way, we statically guarantee that we issue shutdown exactly once, even if we early return via <code>?</code> or panic.</p>
<p>First, let's add a shutdown channel to the <code>connection_loop</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_std;
</span><span class="boring">extern crate futures;
</span><span class="boring">use async_std::net::TcpStream;
</span><span class="boring">use futures::channel::mpsc;
</span><span class="boring">use futures::sink::SinkExt;
</span><span class="boring">use std::sync::Arc;
</span><span class="boring">
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;;
</span><span class="boring">type Sender&lt;T&gt; = mpsc::UnboundedSender&lt;T&gt;;
</span><span class="boring">type Receiver&lt;T&gt; = mpsc::UnboundedReceiver&lt;T&gt;;
</span><span class="boring">
</span>#[derive(Debug)]
enum Void {} // 1

#[derive(Debug)]
enum Event {
    NewPeer {
        name: String,
        stream: Arc&lt;TcpStream&gt;,
        shutdown: Receiver&lt;Void&gt;, // 2
    },
    Message {
        from: String,
        to: Vec&lt;String&gt;,
        msg: String,
    },
}

async fn connection_loop(mut broker: Sender&lt;Event&gt;, stream: Arc&lt;TcpStream&gt;) -&gt; Result&lt;()&gt; {
    // ...
<span class="boring">  let name: String = unimplemented!();
</span>    let (_shutdown_sender, shutdown_receiver) = mpsc::unbounded::&lt;Void&gt;(); // 3
    broker.send(Event::NewPeer {
        name: name.clone(),
        stream: Arc::clone(&amp;stream),
        shutdown: shutdown_receiver,
    }).await.unwrap();
    // ...
<span class="boring">  unimplemented!()
</span>}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>To enforce that no messages are sent along the shutdown channel, we use an uninhabited type.</li>
<li>We pass the shutdown channel to the writer task.</li>
<li>In the reader, we create a <code>_shutdown_sender</code> whose only purpose is to get dropped.</li>
</ol>
<p>In the <code>connection_writer_loop</code>, we now need to choose between shutdown and message channels.
We use the <code>select</code> macro for this purpose:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_std;
</span><span class="boring">extern crate futures;
</span><span class="boring">use async_std::{net::TcpStream, prelude::*};
</span><span class="boring">use futures::channel::mpsc;
</span>use futures::{select, FutureExt};
<span class="boring">use std::sync::Arc;
</span><span class="boring">type Receiver&lt;T&gt; = mpsc::UnboundedReceiver&lt;T&gt;;
</span><span class="boring">type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;;
</span><span class="boring">type Sender&lt;T&gt; = mpsc::UnboundedSender&lt;T&gt;;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum Void {} // 1
</span>
async fn connection_writer_loop(
    messages: &amp;mut Receiver&lt;String&gt;,
    stream: Arc&lt;TcpStream&gt;,
    shutdown: Receiver&lt;Void&gt;, // 1
) -&gt; Result&lt;()&gt; {
    let mut stream = &amp;*stream;
    let mut messages = messages.fuse();
    let mut shutdown = shutdown.fuse();
    loop { // 2
        select! {
            msg = messages.next().fuse() =&gt; match msg {
                Some(msg) =&gt; stream.write_all(msg.as_bytes()).await?,
                None =&gt; break,
            },
            void = shutdown.next().fuse() =&gt; match void {
                Some(void) =&gt; match void {}, // 3
                None =&gt; break,
            }
        }
    }
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>We add shutdown channel as an argument.</li>
<li>Because of <code>select</code>, we can't use a <code>while let</code> loop, so we desugar it further into a <code>loop</code>.</li>
<li>In the shutdown case we use <code>match void {}</code> as a statically-checked <code>unreachable!()</code>.</li>
</ol>
<p>Another problem is that between the moment we detect disconnection in <code>connection_writer_loop</code> and the moment when we actually remove the peer from the <code>peers</code> map, new messages might be pushed into the peer's channel.
To not lose these messages completely, we'll return the messages channel back to the broker.
This also allows us to establish a useful invariant that the message channel strictly outlives the peer in the <code>peers</code> map, and makes the broker itself infallible.</p>
<h2><a class="header" href="#final-code" id="final-code">Final Code</a></h2>
<p>The final code looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate async_std;
</span><span class="boring">extern crate futures;
</span>use async_std::{
    io::BufReader,
    net::{TcpListener, TcpStream, ToSocketAddrs},
    prelude::*,
    task,
};
use futures::channel::mpsc;
use futures::sink::SinkExt;
use futures::{select, FutureExt};
use std::{
    collections::hash_map::{Entry, HashMap},
    future::Future,
    sync::Arc,
};

type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;;
type Sender&lt;T&gt; = mpsc::UnboundedSender&lt;T&gt;;
type Receiver&lt;T&gt; = mpsc::UnboundedReceiver&lt;T&gt;;

#[derive(Debug)]
enum Void {}

// main
fn run() -&gt; Result&lt;()&gt; {
    task::block_on(accept_loop(&quot;127.0.0.1:8080&quot;))
}

async fn accept_loop(addr: impl ToSocketAddrs) -&gt; Result&lt;()&gt; {
    let listener = TcpListener::bind(addr).await?;
    let (broker_sender, broker_receiver) = mpsc::unbounded();
    let broker_handle = task::spawn(broker_loop(broker_receiver));
    let mut incoming = listener.incoming();
    while let Some(stream) = incoming.next().await {
        let stream = stream?;
        println!(&quot;Accepting from: {}&quot;, stream.peer_addr()?);
        spawn_and_log_error(connection_loop(broker_sender.clone(), stream));
    }
    drop(broker_sender);
    broker_handle.await;
    Ok(())
}

async fn connection_loop(mut broker: Sender&lt;Event&gt;, stream: TcpStream) -&gt; Result&lt;()&gt; {
    let stream = Arc::new(stream);
    let reader = BufReader::new(&amp;*stream);
    let mut lines = reader.lines();

    let name = match lines.next().await {
        None =&gt; Err(&quot;peer disconnected immediately&quot;)?,
        Some(line) =&gt; line?,
    };
    let (_shutdown_sender, shutdown_receiver) = mpsc::unbounded::&lt;Void&gt;();
    broker.send(Event::NewPeer {
        name: name.clone(),
        stream: Arc::clone(&amp;stream),
        shutdown: shutdown_receiver,
    }).await.unwrap();

    while let Some(line) = lines.next().await {
        let line = line?;
        let (dest, msg) = match line.find(':') {
            None =&gt; continue,
            Some(idx) =&gt; (&amp;line[..idx], line[idx + 1 ..].trim()),
        };
        let dest: Vec&lt;String&gt; = dest.split(',').map(|name| name.trim().to_string()).collect();
        let msg: String = msg.trim().to_string();

        broker.send(Event::Message {
            from: name.clone(),
            to: dest,
            msg,
        }).await.unwrap();
    }

    Ok(())
}

async fn connection_writer_loop(
    messages: &amp;mut Receiver&lt;String&gt;,
    stream: Arc&lt;TcpStream&gt;,
    shutdown: Receiver&lt;Void&gt;,
) -&gt; Result&lt;()&gt; {
    let mut stream = &amp;*stream;
    let mut messages = messages.fuse();
    let mut shutdown = shutdown.fuse();
    loop {
        select! {
            msg = messages.next().fuse() =&gt; match msg {
                Some(msg) =&gt; stream.write_all(msg.as_bytes()).await?,
                None =&gt; break,
            },
            void = shutdown.next().fuse() =&gt; match void {
                Some(void) =&gt; match void {},
                None =&gt; break,
            }
        }
    }
    Ok(())
}

#[derive(Debug)]
enum Event {
    NewPeer {
        name: String,
        stream: Arc&lt;TcpStream&gt;,
        shutdown: Receiver&lt;Void&gt;,
    },
    Message {
        from: String,
        to: Vec&lt;String&gt;,
        msg: String,
    },
}

async fn broker_loop(events: Receiver&lt;Event&gt;) {
    let (disconnect_sender, mut disconnect_receiver) = // 1
        mpsc::unbounded::&lt;(String, Receiver&lt;String&gt;)&gt;();
    let mut peers: HashMap&lt;String, Sender&lt;String&gt;&gt; = HashMap::new();
    let mut events = events.fuse();
    loop {
        let event = select! {
            event = events.next().fuse() =&gt; match event {
                None =&gt; break, // 2
                Some(event) =&gt; event,
            },
            disconnect = disconnect_receiver.next().fuse() =&gt; {
                let (name, _pending_messages) = disconnect.unwrap(); // 3
                assert!(peers.remove(&amp;name).is_some());
                continue;
            },
        };
        match event {
            Event::Message { from, to, msg } =&gt; {
                for addr in to {
                    if let Some(peer) = peers.get_mut(&amp;addr) {
                        let msg = format!(&quot;from {}: {}\n&quot;, from, msg);
                        peer.send(msg).await
                            .unwrap() // 6
                    }
                }
            }
            Event::NewPeer { name, stream, shutdown } =&gt; {
                match peers.entry(name.clone()) {
                    Entry::Occupied(..) =&gt; (),
                    Entry::Vacant(entry) =&gt; {
                        let (client_sender, mut client_receiver) = mpsc::unbounded();
                        entry.insert(client_sender);
                        let mut disconnect_sender = disconnect_sender.clone();
                        spawn_and_log_error(async move {
                            let res = connection_writer_loop(&amp;mut client_receiver, stream, shutdown).await;
                            disconnect_sender.send((name, client_receiver)).await // 4
                                .unwrap();
                            res
                        });
                    }
                }
            }
        }
    }
    drop(peers); // 5
    drop(disconnect_sender); // 6
    while let Some((_name, _pending_messages)) = disconnect_receiver.next().await {
    }
}

fn spawn_and_log_error&lt;F&gt;(fut: F) -&gt; task::JoinHandle&lt;()&gt;
where
    F: Future&lt;Output = Result&lt;()&gt;&gt; + Send + 'static,
{
    task::spawn(async move {
        if let Err(e) = fut.await {
            eprintln!(&quot;{}&quot;, e)
        }
    })
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>In the broker, we create a channel to reap disconnected peers and their undelivered messages.</li>
<li>The broker's main loop exits when the input events channel is exhausted (that is, when all readers exit).</li>
<li>Because broker itself holds a <code>disconnect_sender</code>, we know that the disconnections channel can't be fully drained in the main loop.</li>
<li>We send peer's name and pending messages to the disconnections channel in both the happy and the not-so-happy path.
Again, we can safely unwrap because the broker outlives writers.</li>
<li>We drop <code>peers</code> map to close writers' messages channel and shut down the writers for sure.
It is not strictly necessary in the current setup, where the broker waits for readers' shutdown anyway.
However, if we add a server-initiated shutdown (for example, kbd:[ctrl+c] handling), this will be a way for the broker to shutdown the writers.</li>
<li>Finally, we close and drain the disconnections channel.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../tutorial/clean_shutdown.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../tutorial/implementing_a_client.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../tutorial/clean_shutdown.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../tutorial/implementing_a_client.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
