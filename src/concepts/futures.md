# Futures

Rust에서 주목할만한 점 중 하나가 [_겁없는 동시성_](https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html)입니다. 이 말은 사용자가 안전성을 포기하지 않고 동시성을 처리할 수 있는 권한을 받는다는 뜻입니다. 또한 Rust는 저수준 언어로 _특정 구현 전략을 선택하지 않아도_ 겂없는 동시성을 실현할 수 있다는 뜻이기도 합니다. 즉 다른 전략의 사용자 간에 코드를 공유할 수도 있으니 나중에 *선택*할 수 있기 위해 전략을 추상화해야 한다는 뜻이도 하죠.

Futures *계산*을 추상화합니다. "언제"와 "어디서"와 상관없이 "무엇을" 처리할 지만 기술하는 거죠. 이를 위해 Futures는 코드를 작고 조합가능한 동작으로 쪼개는 것에 집중합니다. 그래서 시스템의 각 부분에서 작동시키는 거죠. 어디서 추상화할 수 있는 지를 찾기 위해 계산한다는 것이 무슨 뜻인지 살펴봅시다.

## Send와 Sync

다행히 Rust의 동시성은 이미 잘 알려져 있고 효과적인 개념 두 가지를 가지고 있습니다. 프로그램의 동시성 부분 사이의 공유를 추상화한 것으로 바로 `Send`와 `Sync`입니다. 특히 `Send`와 `Sync` 트레잇은 모두 동시성 작업의 *전략*을 추상화하고 깔끔하게 조합하며 구현방식을 제한하지 않는 특징이 있습니다.

짧게 요약하자면 아래와 같습니다.

- `Send`는 계산이 다른 동시성 계산(동시성을 다룰 때 데이터를 보내는 계산를 '센더', 전달받는 계산를 '리시버'라고 부릅니다)에 *전달하는 데이터*를 추상화하고 데이터를 보내면 보낸 측에서는 접근 권한을 잃게 합니다. 많은 프로그래밍 언어들에서 일반적으로 이 전략을 이용해서 동시성을 구현합니다. 하지만 언어 차원에서 지원하지는 않고 사용자에게 "접근권한 상실"을 직접 구현하게 합니다. '센더'가 전달한 데이터에 대해서 여전히 제어권을 가지고 있고 심지어 어떤 작업을 하는 것은 버그를 일으키는 대표적인 경우죠. Rust는 이 행위를 명시해서 버그가 생길 가능성을 다음과 같이 낮춰줍니다. 어떤 타입이 (적절한 마커 트레잇을 구현해서) `Send`이면 데이터를 다른 계산에 보낼 수 있습니다. 그리고 Rust의 소유권과 대여 규칙이 후속 접근을 방지합니다.

- `Sync`는 다른 동시성 계산과 *공유하는 데이터*에 대한 것입니다. `Send`와 마찬가지로 흔히 쓰는 또다른 패턴이기도 합니다. 다른 쪽에서 메모리에 쓰기 기능을 사용하는 동안 같은 위치에 쓰거나 그것을 읽는 것은 본질적으로 안전하지 않기 때문에 이런 접근은 동기화를 통해서 조정해야 합니다.[^1] 양측이 메모리의 위치를 동시에 사용하지 않기로 동의하는 방법은 mutex, spinlock 등 여러가지 방식이 사용되고 있습니다. 다시 말하지만 Rust는 (무려 안전하게!) 동기화 방법을 신경쓰지 않을 옵션도 제공합니다. Rust는 사용자가 *방법*은 구체화하지 않더라도 동기화가 필요한 대상이라고 표시할 수 있게 해줍니다.

*"쓰레드"*라는 단어를 쓰는 것을 피하고 대신 "계산"이라고 표기한 것을 주의해주세요. `Send`와 `Sync`의 잠재력은 사용자가 *무엇*을 공유할 지에 대해서 알아야 하는 부담을 덜어주는 것입니다. 구현하는 시점에서 사용자는 지금 다루고 있는 타입에 어느 공유 방식이 적절한지만 알면 됩니다. 이를 통해 추론을 국지적으로 할 수 있고 해당 타입의 사용자가 나중에 작성하는 구현에도 영향을 받지 않게 됩니다.

`Send`와 `Sync`는 흥미로운 방식으로 구성할 수 있으나 이 문서에 다룰 범위는 아닌 것 같습니다. [Rust Book][rust-book-sync]에서 예시를 찾을 수 있습니다.

[rust-book-sync]: https://doc.rust-lang.org/stable/book/ch16-04-extensible-concurrency-sync-and-send.html

요약하면 Rust는 동시성 프로그램의 중요한 요소들과 데이터 공유를 안전하게 추상화할 수 있게 해줍니다. 굉장히 가벼운 방식으로요. 프로그래밍 언어 자체는 `Send`와 `Sync` 두 가지 마커만 알고 있고 그 기능을 확장해서 조금의 도움만 주기 때문입니다. 나머지는 모두 라이브러리가 처리하는 거죠.

## 계산(computation)에 대한 간단한 관점

계산에 대해서 다루면 그에 대한 [책](https://computationbook.com/)을 한 권 쓸 수 있지만 매우 단순화시킨 관점만 이해해도 충분합니다. 계산(Computation)이란 결정에 따라 분기하고 연속으로 실행되며 결과나 오류를 생성해내는, 조합가능한 일련의 작업(operation)들입니다.

## 계산 미루기

위에서 다뤘듯이 `Send`와 `Sync`는 데이터에 관한 것입니다. 하지만 프로그램은 데이터 뿐만이 아니라 데이터를 *계산하는 것*에 대해서도 다룹니다. 이게 [`Futures`][futures]가 담당하는 일입니다. 어떻게 작동하는 지는 다음 장에서 자세하게 살펴볼 것입니다. 여기서는 Futures가 무엇을 가능하게 해주는 지를 코드가 아니라 문장으로 살펴보겠습니다. Futures는 아래와 같이 작동합니다.

- X를 실행
- X가 성공하면, Y를 실행

Futures를 통해 위의 계획이 아래와 같이 바뀝니다:

- X 실행 시작
- X가 성공하면, Y 실행 시작

이번 장의 제목이 "계산 미루기"였던 것이 기억나나요? 그게 전부입니다. 컴퓨터에게 _지금_ 무언 가를 실행하고 결정하라고 말하는 대신 무엇을 시작해야 하는지 그리고 잠재적인 이벤트에 대해서 어떻게 대응해야 하는지를 말해주는 겁니다. 잠재적인 이벤트가 바로... `Future`에서 발생하죠.

[futures]: https://doc.rust-lang.org/std/future/trait.Future.html

## 시작을 지향하기

간단한 함수를 하나 봅시다. 반환값에 주목해주세요.

```rust,edition2018
# use std::{fs::File, io, io::prelude::*};
#
fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

이 함수는 언제든 부를 수 있기 때문에 호출할 때는 모든 권한을 다 가집니다. 그런데 여기에 문제가 있습니다. 사용자가 함수를 호출하는 순간, 반환값이 나올 때까지 제어권을 호출된 함수에 넘겨야 합니다.
그리고 거기서 나온 반환값은 과거에 끝난 결과를 의미합니다. 과거의 결과물에는 단점이 있습니다. 모든 결정이 이미 끝났다는 겁니다. 과거의 결과물에는 장점도 있습니다. 결과물이 명확하게 보입니다. 프로그램의 과거 계산 결과(Result)를 바로 unwrap해서 그걸로 무엇을 할 지 결정할 수 있습니다.

하지만 *계산*을 추상화해서 어떻게 작동시킬 지는 다른 사람이 선택할 수 있는 방식이 필요합니다. 항상 이전 계산의 결과물을 보여주는 것과는 근본적으로 호환되지 않는 방법이죠. 그래서 실행하지 않고도 계산을 _기술할 수_ 있는 타입을 찾아보겠습니다. 그 함수를 다시 한 번 살펴봅시다.

```rust,edition2018
# use std::{fs::File, io, io::prelude::*};
#
fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

시간의 관점에서 보면 함수를 호출하기 _전이나_ 함수 결과가 반환된 _이후에만_ 어떤 조치를 취할 수 있습니다. 함수가 작동하는 _동안에는_ 무언가를 할 수 있는 권한을 가져가버리니까 바람직하지 않죠. 병렬 코드로 작업할 때는 그 병렬 코드를 시작할 수 있는 권한을 가져갈 수도 있습니다(코드에서 제어권을 줬으니까요).

[쓰레드](https://en.wikipedia.org/wiki/Thread_)를 이야기해야 할 시점이 바로 지금입니다. 하지만 쓰레드는 매우 특정한 동시성 원시자료형이라서 우리는 계속 "추상화"를 찾는다고 썼습니다.

우리가 찾고 있는 것은 미래에 나올 결과를 향해 지금 작동하는 어떤 작업을 표현하는 "무언가"입니다. Rust에서 "무언가"라고 하면 거의 대부분 트레잇이죠. `Future` 트레잇의 불완전한 정의를 살펴보는 것에서부터 시작해봅시다.

```rust,edition2018
# use std::{pin::Pin, task::{Context, Poll}};
#
trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}
```

트레잇 정의를 자세히 살펴보면 다음 사항들을 알 수 있습니다.

- `Output`을 이용하는 제네릭입니다.
- 현재의 계산 상태를 확인할 수 있는 `poll`이라는 함수를 제공합니다.
- (`Pin`과 `Context`는 일단 무시해도 됩니다. 고수준에서 이해하는데는 불필요합니다.)

`poll()`을 호출하면 아래의 둘 중 하나가 결과로 나옵니다.

1. 계산이 완료될 경우, `poll`에서는 [`Poll::Ready`](https://doc.rust-lang.org/std/task/enum.Poll.html#variant.Ready)를 반환합니다.
2. 계산이 완료되지 않은 경우, [`Poll::Pending`](https://doc.rust-lang.org/std/task/enum.Poll.html#variant.Pending)를 반환합니다.

이를 통해 사용자는 `Future`가 아직 작업을 덜 끝냈는지 아니면 이미 끝내고 결과값을 반환할 수 있는 상태인지를 명시적으로 알 수 있습니다. 가장 단순한 (그러나 효율적이지 않은) 방법은 루프를 이용해서 계속 future의 상태를 확인하는 방법입니다. 최적화가 가능하며 좋은 런타임이 실제로 작동하는 방식이기도 합니다.
1번의 경우처럼 계산이 완료되었는데 `poll`을 다시 호출하는 것은 혼란을 유발할 수도 있습니다. 자세한 사항은 [futures-docs](https://doc.rust-lang.org/std/future/trait.Future.html)를 참고하세요.

## Async

`Future` 트레잇은 Rust에 꽤 오래 존재했지만 이를 빌드하고 기술하는 것은 상당히 불편했습니다. `Future` 트레잇을 좀 더 편하게 사용하기 위해 Rust는 특별한 문법을 하나 만들었는데 바로 `async`입니다. 위에 나온 내용을 `async-std`로 구현한 예시는 아래와 같습니다.

```rust,edition2018
# extern crate async_std;
# use async_std::{fs::File, io, io::prelude::*};
#
async fn read_file(path: &str) -> io::Result<String> {
    let mut file = File::open(path).await?;
    let mut contents = String::new();
    file.read_to_string(&mut contents).await?;
    Ok(contents)
}
```

놀랍게도 거의 차이가 없죠? 해야 하는 일은 함수 앞에 `async`라고 써주는 것과 `.await`라는 특별한 명령어를 두 개 더 집어넣은 것 뿐입니다.

`async` 함수는 지연된 계산을 설정하는 역할을 합니다. 이 함수가 호출되면 `io::Result<String>`를 반환하는 대신 `Future<Output = io::Result<String>>`를 생성합니다.(더 정확하게는, `Future<Output = io::Result<String>>`를 구현한 타입을 생성하는 거죠.)(역자 주: 동기 함수였다면 호출 즉시 계산을 시작해서 함수에 쓰인 대로 `io::Result<String>`를 반환해야겠지만 `async`를 앞에 적으면 "언제인지도 모르고 그리고 어디서 일지도 모르겠지만" `io::Result<String>`를 반환할 수 있는 타입(`Future`)을 반환하는 것입니다.)

## `.await`은 뭘 하는 거죠?

`.await`이라는 접미사는 주석에 나와있는 것처럼 사용됩니다. `.await`를 사용했을 때 해당 코드는 요청된 작업(파일을 열거나 그 안에 있는 데이터를 모두 읽어들이는, 그러니까 `.await`이 붙은 코드에 따른 작업)이 마무리될 때까지 기다릴 것입니다. `.await?`도 대단한 게 아닙니다. 그냥 `.await`의 결과에 `?` 연산자를 적용하는 것일 뿐입니다. 그러면 초기 코드 예시에서 얻은 것이 무엇인가요? future를 받고는 그냥 기다리면 될까요?

`.await`는 여기서 마커 역할을 합니다. 여기서 코드는 `Future`가 결과로 나오는 값을 생성하기를 기다리는 겁니다. 그러면 future는 어떻게 끝날까요? 신경 쓸 필요가 없습니다! `.await` 마커는 계산이 완료될 때까지 해야 하는 다른 업무 관리도 이 코드의 실행 책임을 가지고 있는 컴포넌트(보통 런타임이라고 부릅니다)에게 넘기기 때문입니다. 백그라운드에서 수행중인 작업이 완료되면 다시 이 지점으로 돌아오면 됩니다. 그래서 이런 프로그래밍 스타일을 *이벤트 프로그래밍*이라고 부릅니다. (파일을 여는 등의) 이벤트가 일어나기를 기다렸다가 그에 대해 반응(내용을 읽기)하면 되기 때문입니다.

이런 함수를 두 개 이상 동시에 실행하면 런타임 시스템이 현재 진행중인 *다른 모든 이벤트*를 처리하면서 대기 시간을 채우는 것이 가능합니다.

## 결론

결과값을 다루면서 *(이미 계산된 결과값이 아니라) 향후에 나올 결과값을 계산하고 있는 상태*를 표현할 방법을 찾아봤습니다. 거기서 폴링(polling) 개념을 다뤘죠.

`Future`는 어떤 값을 표현하지는 않지만 _미래의 언젠가 값을 만들 수 있는_ 상태입니다. 이를 구현하는 방법은 경우에 따라 매우 다양하고 복잡하지만 인터페이스는 간단합니다.

다음 절에서는 실제로 Future를 *작동*하기 위해서 사용할 `tasks`를 소개할 것입니다.

[^1]: 아무도 쓰기를 하지 않는다는 것이 보장된다면 두 당사자가 데이터를 읽는 것은 항상 안전합니다.

[futures]: https://rust-lang.github.io/async-book/02_execution/02_future.html
