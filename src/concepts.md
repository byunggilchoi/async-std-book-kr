# async-std를 이용한 비동기 개념

[Rust Futures][futures]는 어렵기로 악명이 높습니다. 하지만 우리는 그렇게 생각하지 않습니다. 우리 생각에는 Rust의 Futures가 가장 쉬운 동시성 개념 중에 하나이고 직관적입니다.(역자 주:... 정말요?)

물론 그런 악명에는 이유가 있습니다. Futures 혼란의 근원으로 보이는 세 가지 개념을 바닥에 깔고 있습니다. 바로 지연된 계산(deferred computation), 비동기성(asynchronicity), 실행전략분리(independence of execution strategy)입니다.

이 개념들이 어렵지는 않지만 대부분의 사람들에게 익숙하지 않습니다. 기본 개념에서 오는 혼란이 세부 사항에 기반한 다양한 구현 과정을 거치면서 증폭됩니다. 이러한 구현에 대한 대부분의 설명은 능력자들을 대상으로 상정하고 있기 때문에 (역자 주: 저같은) 초보자들은 이해하기가 힘듭니다. 우리는 개념에 대해서 초보자도 접근가능한 개요를 제공하고 기본 요소들에 대해서 이해하기 쉽게 설명하려고 합니다.

Futures는 코드를 작동시키는 방법을 추상화한 개념입니다. 그 자체로는 아무 것도 하지 않습니다. 코드가 하나씩 차례대로 작동하는 명령형 언어 입장에서는 기괴한 개념이죠.

그렇다면 Futures는 어떻게 작동할까요? Futures는 자신을 _실행하는_ 코드가 작동할 때까지 아무 것도 하지 않을 겁니다. 실행시키는 코드를 *실행자(executor)*라고 부릅시다. _실행자_ 는 future코드들을 _언제_ 그리고 _어떻게_ 실행할 지를 결정합니다. `async-std::task` 모듈은 실행자를 상대할 수 있는 인터페이스를 제공합니다.

그러면 동기부여를 조금 해드리면서 시작해보도록 하죠.

[futures]: https://en.wikipedia.org/wiki/Futures_and_promises
